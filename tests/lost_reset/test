#!/usr/bin/perl

use strict;
use File::Temp qw/ tempdir tempfile /;
use Test;
BEGIN { plan tests => 15 }    # 5 + 10 main loop iterations

###
# functions

###
# setup

# reset audit rules
system("auditctl -D >& /dev/null");

# create stdout/stderr sinks
( my $fh_out, my $stdout ) = tempfile(
    TEMPLATE => '/tmp/audit-testsuite-out-XXXX',
    UNLINK   => 1
);
( my $fh_err, my $stderr ) = tempfile(
    TEMPLATE => '/tmp/audit-testsuite-err-XXXX',
    UNLINK   => 1
);
( my $fh_tmp, my $tmpout ) = tempfile(
    TEMPLATE => '/tmp/audit-testsuite-tmp-XXXX',
    UNLINK   => 1
);

# store audit kernel config
( my $fh_cfg, my $cfgout ) = tempfile(
    TEMPLATE => '/tmp/audit-testsuite-cfg-XXXX',
    UNLINK   => 1
);
system("auditctl -s > $cfgout");

my $result;
my $i;
for ( $i = 0 ; $i < 10 ; $i++ ) {    # iteration count of 10
     # Kill the daemon, set the buffers low, set the wait time to 1ms, turn on auditing
    system("service auditd stop >/dev/null 2>&1");
    system("auditctl -D >/dev/null 2>&1");
    system("auditctl -b 1 >/dev/null 2>&1");
    system("auditctl --backlog_wait_time 1 >/dev/null 2>&1");
    system("auditctl -e 1 >/dev/null 2>&1");

    ###
    # tests
    # Start floodping to generate activity
    seek( $fh_tmp, 0, 0 );
    system("ping -f 127.0.0.1 >/dev/null 2>&1 & echo \$! >$tmpout");
    my $ping_pid = <$fh_tmp>;
    chomp($ping_pid);

    # Add rule to generate audit queue events from floodping
    $result =
      system("auditctl -a exit,always -S all -F pid=$ping_pid >/dev/null 2>&1");
    ok( $result, 0 );    # Was the rule added successfully?
    sleep 1;
    kill 'TERM', $ping_pid;
    system("auditctl -d exit,always -S all -F pid=$ping_pid >/dev/null 2>&1");

    # Restart the daemon to collect messages in the log
    system("service auditd start >/dev/null 2>&1");
    sleep 1;
}

# send the reset lost message (NOTE: requires bash)
seek( $fh_tmp, 0, 0 );
$result = system(
    "echo \$BASHPID\ >$tmpout; exec auditctl --reset-lost >$stdout 2>$stderr");
ok( $result, 0 );    # Was the reset command successful?
my $reset_lost_pid = <$fh_tmp>;
chomp($reset_lost_pid);
my $reset_err = <$fh_err>;
$reset_err =~ /lost: ([0-9]+)/;
my $result_lost = $1;
ok( $result_lost > 0 );    # Was the lost value non-zero?

sleep 1;

# find the config change event
seek( $fh_out, 0, 0 );
seek( $fh_err, 0, 0 );
$result = system("ausearch -ts recent -i -m CONFIG_CHANGE >$stdout 2>$stderr");
ok( $result, 0 );          # Was an event found?

# test if we generate the lost reset record correctly
my $line;
my $found_msg = 0;
my $lost      = 0;
while ( $line = <$fh_out> ) {

    # find the CONFIG_CHANGE record
    if ( $line =~ /^type=CONFIG_CHANGE / ) {

        # find the lost value
        if ( $line =~ / lost=0 old=([0-9]+) / ) {
            $lost      = $1;
            $found_msg = 1;
        }
    }
}
ok( $found_msg, 1 );    # Was the message well-formed?
ok( $result_lost == $lost );    # Do the two lost values agree?

if ( defined $ENV{ATS_DEBUG} && $ENV{ATS_DEBUG} == 1 ) {
    if ( !$result_lost || !$lost || $result_lost != $lost ) {
        print "lost_rc: $result_lost\n";
        print "lost_msg: $lost\n";
        print "loop completed $i times\n";
    }
}

###
# cleanup
while ( $line = <$fh_cfg> ) {
    my @fields = split /\s+/, $line;
    if ( $fields[0] eq "backlog_limit" ) {
        system("auditctl -b $fields[1] >/dev/null 2>&1");
    }
    if ( $fields[0] eq "backlog_wait_time" ) {
        system("auditctl --backlog_wait_time $fields[1] >/dev/null 2>&1");
    }
}
system("service auditd restart 2>/dev/null");
